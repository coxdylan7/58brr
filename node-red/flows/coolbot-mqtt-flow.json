[
    {
        "id": "coolbot-mqtt-tab",
        "type": "tab",
        "label": "CoolBot MQTT Control",
        "disabled": false,
        "info": "MQTT-based CoolBot automation for ESP32 hub with heating diode"
    },
    {
        "id": "mqtt-broker-config",
        "type": "mqtt-broker",
        "name": "CoolBot MQTT Broker",
        "broker": "localhost",
        "port": "1883",
        "clientid": "coolbot_nodered",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "birthTopic": "coolbot/nodered/status",
        "birthQos": "1",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "coolbot/nodered/status",
        "closeQos": "1",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "coolbot/nodered/status",
        "willQos": "1",
        "willPayload": "offline",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "room-temp-mqtt",
        "type": "mqtt in",
        "z": "coolbot-mqtt-tab",
        "name": "Room Temperature",
        "topic": "coolbot/sensors/room_temp",
        "qos": "1",
        "datatype": "json",
        "broker": "mqtt-broker-config",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 100,
        "wires": [["parse-room-temp"]]
    },
    {
        "id": "coil-temp-mqtt",
        "type": "mqtt in",
        "z": "coolbot-mqtt-tab",
        "name": "Coil Temperature",
        "topic": "coolbot/sensors/coil_temp",
        "qos": "1",
        "datatype": "json",
        "broker": "mqtt-broker-config",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 160,
        "wires": [["parse-coil-temp"]]
    },
    {
        "id": "esp32-status-mqtt",
        "type": "mqtt in",
        "z": "coolbot-mqtt-tab",
        "name": "ESP32 Status",
        "topic": "coolbot/esp32/status",
        "qos": "1",
        "datatype": "json",
        "broker": "mqtt-broker-config",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 220,
        "wires": [["parse-esp32-status"]]
    },
    {
        "id": "parse-room-temp",
        "type": "function",
        "z": "coolbot-mqtt-tab",
        "name": "Parse Room Temp",
        "func": "try {\n    const data = typeof msg.payload === 'string' ? JSON.parse(msg.payload) : msg.payload;\n    const roomTemp = parseFloat(data.temperature);\n    \n    if (isNaN(roomTemp)) {\n        node.warn('Invalid room temperature reading');\n        return null;\n    }\n    \n    flow.set('room_temp', roomTemp);\n    flow.set('room_temp_last_update', Date.now());\n    \n    msg.temperature = roomTemp;\n    msg.sensor = 'room';\n    msg.timestamp = data.timestamp || Date.now();\n    \n    return msg;\n} catch(e) {\n    node.error('Error parsing room temperature: ' + e.message);\n    return null;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 100,
        "wires": [["decision-logic"]]
    },
    {
        "id": "parse-coil-temp",
        "type": "function",
        "z": "coolbot-mqtt-tab",
        "name": "Parse Coil Temp",
        "func": "try {\n    const data = typeof msg.payload === 'string' ? JSON.parse(msg.payload) : msg.payload;\n    const coilTemp = parseFloat(data.temperature);\n    \n    if (isNaN(coilTemp)) {\n        node.warn('Invalid coil temperature reading');\n        return null;\n    }\n    \n    flow.set('coil_temp', coilTemp);\n    flow.set('coil_temp_last_update', Date.now());\n    \n    msg.temperature = coilTemp;\n    msg.sensor = 'coil';\n    msg.timestamp = data.timestamp || Date.now();\n    \n    return msg;\n} catch(e) {\n    node.error('Error parsing coil temperature: ' + e.message);\n    return null;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 160,
        "wires": [["decision-logic"]]
    },
    {
        "id": "parse-esp32-status",
        "type": "function",
        "z": "coolbot-mqtt-tab",
        "name": "Parse ESP32 Status",
        "func": "try {\n    const data = typeof msg.payload === 'string' ? JSON.parse(msg.payload) : msg.payload;\n    \n    flow.set('esp32_online', data.online || false);\n    flow.set('esp32_uptime', data.uptime || 0);\n    flow.set('wifi_rssi', data.wifi_rssi || -100);\n    flow.set('heating_diode_temp', data.heating_diode_temp || 0);\n    flow.set('esp32_last_seen', Date.now());\n    \n    // Check if ESP32 is having issues\n    if (data.wifi_rssi < -80) {\n        node.warn(`Weak WiFi signal: ${data.wifi_rssi}dBm`);\n    }\n    \n    if (data.free_heap < 10000) {\n        node.warn(`Low memory: ${data.free_heap} bytes free`);\n    }\n    \n    return msg;\n} catch(e) {\n    node.error('Error parsing ESP32 status: ' + e.message);\n    return null;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 220,
        "wires": [["esp32-health-check"]]
    },
    {
        "id": "decision-logic",
        "type": "function",
        "z": "coolbot-mqtt-tab",
        "name": "CoolBot Decision Logic",
        "func": "// Get current values\nconst roomTemp = flow.get('room_temp') || 999;\nconst coilTemp = flow.get('coil_temp') || 999;\nconst targetTemp = flow.get('target_temp') || 30;\nconst hysteresis = flow.get('hysteresis') || 2;\nconst coilFreezeThreshold = flow.get('coil_freeze_threshold') || 33;\nconst coilResumeThreshold = flow.get('coil_resume_threshold') || 36;\nconst acStatus = flow.get('ac_status') || 'off';\nconst lastOffTime = flow.get('last_off_time') || 0;\nconst minOffTimeMs = (flow.get('min_off_time_minutes') || 8) * 60 * 1000;\nconst acStartTime = flow.get('ac_start_time') || 0;\nconst maxRuntimeMs = (flow.get('max_runtime_hours') || 4) * 60 * 60 * 1000;\nconst heatingDiodeEnabled = flow.get('heating_diode_enabled') !== false; // Default true\nconst esp32Online = flow.get('esp32_online') || false;\n\n// Safety checks\nif (!esp32Online) {\n    flow.set('system_status', 'esp32_offline');\n    node.warn('ESP32 offline - entering safe mode');\n    return [null, { payload: { command: 'off', reason: 'esp32_offline' }}];\n}\n\nif (roomTemp === 999 || coilTemp === 999) {\n    flow.set('system_status', 'sensor_error');\n    node.warn('Sensor reading error - entering safe mode');\n    return [null, { payload: { command: 'off', reason: 'sensor_error' }}];\n}\n\n// Check if minimum off time has passed\nconst timeSinceOff = Date.now() - lastOffTime;\nconst canTurnOn = timeSinceOff > minOffTimeMs;\n\n// Check if AC has been running too long\nconst runtimeMs = acStatus === 'on' ? Date.now() - acStartTime : 0;\nconst runtimeExceeded = runtimeMs > maxRuntimeMs;\n\nlet newStatus = acStatus;\nlet reason = 'normal_operation';\nlet heatingDiodeCommand = null;\n\n// Decision logic\nif (acStatus === 'off') {\n    // AC is currently off - check if we should turn it on\n    if (roomTemp > (targetTemp + hysteresis) && \n        coilTemp > coilResumeThreshold && \n        canTurnOn) {\n        newStatus = 'on';\n        reason = 'cooling_needed';\n        flow.set('ac_start_time', Date.now());\n        \n        // Turn on heating diode when AC starts\n        if (heatingDiodeEnabled) {\n            heatingDiodeCommand = {\n                enabled: true,\n                intensity: flow.get('heating_diode_intensity') || 200,\n                mode: 'auto'\n            };\n        }\n    }\n} else {\n    // AC is currently on - check if we should turn it off\n    if (coilTemp <= coilFreezeThreshold) {\n        newStatus = 'off';\n        reason = 'freeze_protection';\n        flow.set('last_off_time', Date.now());\n        \n        // Turn off heating diode when AC stops\n        heatingDiodeCommand = {\n            enabled: false,\n            intensity: 0,\n            mode: 'off'\n        };\n    } else if (roomTemp <= targetTemp) {\n        newStatus = 'off';\n        reason = 'target_reached';\n        flow.set('last_off_time', Date.now());\n        \n        // Turn off heating diode when target reached\n        heatingDiodeCommand = {\n            enabled: false,\n            intensity: 0,\n            mode: 'off'\n        };\n    } else if (runtimeExceeded) {\n        newStatus = 'off';\n        reason = 'max_runtime_exceeded';\n        flow.set('last_off_time', Date.now());\n        \n        // Turn off heating diode on safety shutdown\n        heatingDiodeCommand = {\n            enabled: false,\n            intensity: 0,\n            mode: 'off'\n        };\n    }\n}\n\n// Update status\nflow.set('ac_status', newStatus);\nflow.set('system_status', reason);\n\n// Create status message\nconst statusMsg = {\n    payload: {\n        room_temp: roomTemp,\n        coil_temp: coilTemp,\n        target_temp: targetTemp,\n        ac_status: newStatus,\n        reason: reason,\n        can_turn_on: canTurnOn,\n        runtime_hours: runtimeMs / (1000 * 60 * 60),\n        time_since_off_minutes: timeSinceOff / (1000 * 60),\n        heating_diode_enabled: heatingDiodeEnabled\n    }\n};\n\n// Output messages\nconst acControlMsg = newStatus !== acStatus ? \n    { payload: { command: newStatus, reason: reason, source: 'nodered', timestamp: Date.now() }} : null;\n\nconst heatingMsg = heatingDiodeCommand ? \n    { payload: heatingDiodeCommand } : null;\n\nreturn [statusMsg, acControlMsg, heatingMsg];",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 140,
        "wires": [["status-display"], ["ac-control-mqtt"], ["heating-diode-control"]]
    },
    {
        "id": "ac-control-mqtt",
        "type": "mqtt out",
        "z": "coolbot-mqtt-tab",
        "name": "AC Control",
        "topic": "coolbot/controls/ac_plug",
        "qos": "1",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt-broker-config",
        "x": 830,
        "y": 120,
        "wires": []
    },
    {
        "id": "heating-diode-control",
        "type": "mqtt out",
        "z": "coolbot-mqtt-tab",
        "name": "Heating Diode",
        "topic": "coolbot/controls/heating_diode",
        "qos": "1",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt-broker-config",
        "x": 850,
        "y": 180,
        "wires": []
    },
    {
        "id": "status-display",
        "type": "function",
        "z": "coolbot-mqtt-tab",
        "name": "Format Status",
        "func": "const data = msg.payload;\n\n// Format for dashboard display\nconst status = {\n    room_temp: Math.round(data.room_temp * 10) / 10,\n    coil_temp: Math.round(data.coil_temp * 10) / 10,\n    target_temp: data.target_temp,\n    ac_status: data.ac_status,\n    status_text: formatStatusText(data.reason),\n    runtime_hours: Math.round(data.runtime_hours * 100) / 100,\n    can_turn_on: data.can_turn_on,\n    heating_diode_enabled: data.heating_diode_enabled,\n    heating_diode_temp: flow.get('heating_diode_temp') || 0,\n    esp32_online: flow.get('esp32_online') || false,\n    wifi_rssi: flow.get('wifi_rssi') || -100,\n    timestamp: new Date().toLocaleString()\n};\n\nfunction formatStatusText(reason) {\n    switch(reason) {\n        case 'cooling_needed': return 'Cooling';\n        case 'freeze_protection': return 'Freeze Protection';\n        case 'target_reached': return 'Target Reached';\n        case 'max_runtime_exceeded': return 'Max Runtime';\n        case 'sensor_error': return 'Sensor Error';\n        case 'esp32_offline': return 'ESP32 Offline';\n        case 'normal_operation': return 'Monitoring';\n        default: return 'Unknown';\n    }\n}\n\nreturn { payload: status };",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 80,
        "wires": [["status-mqtt-out", "dashboard-update"]]
    },
    {
        "id": "status-mqtt-out",
        "type": "mqtt out",
        "z": "coolbot-mqtt-tab",
        "name": "System Status",
        "topic": "coolbot/status/system",
        "qos": "1",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt-broker-config",
        "x": 1050,
        "y": 60,
        "wires": []
    },
    {
        "id": "dashboard-update",
        "type": "function",
        "z": "coolbot-mqtt-tab",
        "name": "Dashboard Output",
        "func": "// Split status for different dashboard elements\nconst status = msg.payload;\n\n// Temperature gauges\nconst tempMsg = {\n    topic: \"temperatures\",\n    payload: {\n        room: status.room_temp,\n        coil: status.coil_temp,\n        target: status.target_temp,\n        diode: status.heating_diode_temp\n    }\n};\n\n// Status text\nconst statusMsg = {\n    topic: \"status\",\n    payload: status.status_text,\n    ac_on: status.ac_status === 'on',\n    esp32_online: status.esp32_online,\n    wifi_rssi: status.wifi_rssi\n};\n\n// Runtime info\nconst runtimeMsg = {\n    topic: \"runtime\", \n    payload: {\n        hours: status.runtime_hours,\n        can_start: status.can_turn_on,\n        heating_diode_on: status.heating_diode_enabled && status.ac_status === 'on',\n        timestamp: status.timestamp\n    }\n};\n\nreturn [tempMsg, statusMsg, runtimeMsg];",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1050,
        "y": 100,
        "wires": [[], [], []]
    },
    {
        "id": "esp32-health-check",
        "type": "function",
        "z": "coolbot-mqtt-tab",
        "name": "ESP32 Health Monitor",
        "func": "const esp32LastSeen = flow.get('esp32_last_seen') || 0;\nconst currentTime = Date.now();\nconst offlineThreshold = 5 * 60 * 1000; // 5 minutes\n\n// Check if ESP32 has been offline too long\nif ((currentTime - esp32LastSeen) > offlineThreshold) {\n    flow.set('esp32_online', false);\n    \n    // Send emergency stop command\n    const emergencyMsg = {\n        payload: {\n            command: 'off',\n            reason: 'esp32_timeout',\n            source: 'watchdog',\n            timestamp: currentTime\n        }\n    };\n    \n    node.warn('ESP32 offline for too long - emergency AC shutdown');\n    return emergencyMsg;\n}\n\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 220,
        "wires": [["ac-control-mqtt"]]
    },
    {
        "id": "init-mqtt-flow",
        "type": "inject",
        "z": "coolbot-mqtt-tab",
        "name": "Initialize MQTT",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "init",
        "payloadType": "str",
        "x": 150,
        "y": 40,
        "wires": [["init-mqtt-settings"]]
    },
    {
        "id": "init-mqtt-settings",
        "type": "function",
        "z": "coolbot-mqtt-tab",
        "name": "Initialize MQTT Settings",
        "func": "// Initialize flow variables with default values\nflow.set('target_temp', 30);\nflow.set('hysteresis', 2);\nflow.set('coil_freeze_threshold', 33);\nflow.set('coil_resume_threshold', 36);\nflow.set('min_off_time_minutes', 8);\nflow.set('max_runtime_hours', 4);\nflow.set('heating_diode_enabled', true); // Required for CoolBot operation\nflow.set('heating_diode_intensity', 200); // Default PWM value\nflow.set('enable_ir_control', false);\nflow.set('ac_status', 'off');\nflow.set('system_status', 'initializing');\nflow.set('last_off_time', 0);\nflow.set('ac_start_time', 0);\nflow.set('esp32_online', false);\nflow.set('esp32_last_seen', Date.now());\n\nnode.log('CoolBot MQTT system initialized with default settings');\n\n// Publish initial settings to ESP32\nconst settingsMsg = {\n    payload: {\n        target_temp: 30,\n        hysteresis: 2,\n        heating_diode_enabled: true,\n        heating_diode_intensity: 200\n    }\n};\n\nreturn settingsMsg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 40,
        "wires": [["settings-mqtt-out"]]
    },
    {
        "id": "settings-mqtt-out",
        "type": "mqtt out",
        "z": "coolbot-mqtt-tab",
        "name": "Settings to ESP32",
        "topic": "coolbot/settings/all",
        "qos": "1",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt-broker-config",
        "x": 630,
        "y": 40,
        "wires": []
    }
]